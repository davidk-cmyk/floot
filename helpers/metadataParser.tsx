/**
 * Represents a single parsed metadata entry.
 */
export type MetadataPair = {
  field: string;
  value: string;
};

/**
 * Extracts a meaningful field name and value from a pipe-separated value.
 * Attempts to identify common patterns and extract field names intelligently.
 */
const extractFieldValueFromPipeValue = (value: string): { field: string, value: string } => {
  const trimmedValue = value.trim();
  
  // Pattern 1: "Version X.Y" -> field: "Version", value: "X.Y"
  const versionMatch = trimmedValue.match(/^(Version)\s+([0-9]+(?:\.[0-9]+)*)$/i);
  if (versionMatch) {
    return { field: "Version", value: versionMatch[2] };
  }
  
  // Pattern 2: "Effective YYYY-MM-DD" -> field: "Effective Date", value: "YYYY-MM-DD"
  const effectiveMatch = trimmedValue.match(/^(Effective)\s+(\d{4}-\d{2}-\d{2})$/i);
  if (effectiveMatch) {
    return { field: "Effective Date", value: effectiveMatch[2] };
  }
  
  // Pattern 3: "Status Active/Inactive/etc" -> field: "Status", value: "Active"
  const statusMatch = trimmedValue.match(/^(Status)\s+(.+)$/i);
  if (statusMatch) {
    return { field: "Status", value: statusMatch[2] };
  }
  
  // Pattern 4: "Department XYZ" -> field: "Department", value: "XYZ"
  const departmentMatch = trimmedValue.match(/^(Department)\s+(.+)$/i);
  if (departmentMatch) {
    return { field: "Department", value: departmentMatch[2] };
  }
  
  // Pattern 5: "Category ABC" -> field: "Category", value: "ABC"
  const categoryMatch = trimmedValue.match(/^(Category)\s+(.+)$/i);
  if (categoryMatch) {
    return { field: "Category", value: categoryMatch[2] };
  }
  
  // Pattern 6: "Created YYYY-MM-DD" -> field: "Created Date", value: "YYYY-MM-DD"
  const createdMatch = trimmedValue.match(/^(Created)\s+(\d{4}-\d{2}-\d{2})$/i);
  if (createdMatch) {
    return { field: "Created Date", value: createdMatch[2] };
  }
  
  // Pattern 7: "Updated YYYY-MM-DD" -> field: "Updated Date", value: "YYYY-MM-DD"
  const updatedMatch = trimmedValue.match(/^(Updated)\s+(\d{4}-\d{2}-\d{2})$/i);
  if (updatedMatch) {
    return { field: "Updated Date", value: updatedMatch[2] };
  }
  
  // Pattern 8: "Expires YYYY-MM-DD" -> field: "Expiration Date", value: "YYYY-MM-DD"
  const expiresMatch = trimmedValue.match(/^(Expires?)\s+(\d{4}-\d{2}-\d{2})$/i);
  if (expiresMatch) {
    return { field: "Expiration Date", value: expiresMatch[2] };
  }
  
  // Pattern 9: Any word followed by a date (generic date pattern)
  const genericDateMatch = trimmedValue.match(/^(\w+)\s+(\d{4}-\d{2}-\d{2})$/);
  if (genericDateMatch) {
    const fieldName = genericDateMatch[1].charAt(0).toUpperCase() + genericDateMatch[1].slice(1).toLowerCase();
    return { field: `${fieldName} Date`, value: genericDateMatch[2] };
  }
  
  // Pattern 10: Any word followed by a version number
  const genericVersionMatch = trimmedValue.match(/^(\w+)\s+([0-9]+(?:\.[0-9]+)+)$/);
  if (genericVersionMatch) {
    const fieldName = genericVersionMatch[1].charAt(0).toUpperCase() + genericVersionMatch[1].slice(1).toLowerCase();
    return { field: fieldName, value: genericVersionMatch[2] };
  }
  
  // Pattern 11: Any single word followed by content (generic pattern)
  const genericMatch = trimmedValue.match(/^(\w+)\s+(.+)$/);
  if (genericMatch && genericMatch[1].length > 2) { // Avoid very short words that might be noise
    const fieldName = genericMatch[1].charAt(0).toUpperCase() + genericMatch[1].slice(1).toLowerCase();
    return { field: fieldName, value: genericMatch[2] };
  }
  
  // Fallback: return as-is with empty field
  return { field: "", value: trimmedValue };
};

/**
 * Parses a processed metadata string into an array of structured field-value pairs.
 * The function supports two primary formats within the input string:
 *
 * 1.  **Colon-Separated Format (per line):**
 *     Each line containing a colon is treated as a distinct field-value pair.
 *     Example: "Title: My Policy\nVersion: 1.2"
 *     Result: `[{ field: 'Title', value: 'My Policy' }, { field: 'Version', value: '1.2' }]`
 *
 * 2.  **Pipe-Separated Format (per line):**
 *     A line without a colon but with pipes is treated as a list of values.
 *     The parser attempts to extract meaningful field names from the values.
 *     Example: "Version 1.2 | Effective 2024-01-01 | Department Engineering"
 *     Result: `[{ field: 'Version', value: '1.2' }, { field: 'Effective Date', value: '2024-01-01' }, { field: 'Department', value: 'Engineering' }]`
 *
 * The parser is designed to be robust, gracefully handling empty lines,
 * missing values, and mixed formats within the same input string.
 *
 * @param metadataString The raw metadata string, typically generated by `layoutRenderer`.
 * @returns An array of `MetadataPair` objects, ready for display in a table or list.
 */
export const parseMetadata = (
  metadataString: string | null | undefined
): MetadataPair[] => {
  if (!metadataString) {
    return [];
  }

  // Normalize escaped newlines to actual newlines before parsing
  const cleaned = metadataString.replace(/\\n/g, '\n');
  
  const results: MetadataPair[] = [];
  const lines = cleaned.split("\n");

  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue; // Skip empty or whitespace-only lines
    }

    const colonIndex = trimmedLine.indexOf(":");

    if (colonIndex > 0) {
      // Colon-separated format found (e.g., "Field: Value")
      const field = trimmedLine.substring(0, colonIndex).trim();
      const value = trimmedLine.substring(colonIndex + 1).trim();
      if (field && value) { // Only add if both field and value are non-empty
        results.push({ field, value });
      }
    } else if (trimmedLine.includes("|")) {
      // Pipe-separated format found (e.g., "Value1 | Value2")
      const values = trimmedLine.split("|");
      for (const value of values) {
        const trimmedValue = value.trim();
        if (trimmedValue) {
          const { field, value: extractedValue } = extractFieldValueFromPipeValue(trimmedValue);
          results.push({ field, value: extractedValue });
        }
      }
    } else {
      // Treat the entire line as a value if no format is matched
      // Try to extract field-value pair even from single lines
      const { field, value } = extractFieldValueFromPipeValue(trimmedLine);
      results.push({ field, value });
    }
  }

  return results;
};